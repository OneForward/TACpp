# 数据结构习题

## 排序

> 问题： 若序列的原始状态为 {1，2，3，4，5，10，6，7，8，9}，要想使得排序过程中元素比较次数最少，则应该采用（）方法
- 插入排序
- 选择排序
- 希尔排序
- 冒泡排序

```
解答：插入排序。对于近似排序好的数组使用插入排序或者（带有 flag 优化的）冒泡排序可以在 O(N) 时间排好序。命题人可能认为这里的冒泡排序的选项是指最早版本的不带优化的版本。
```

---

> 问题：如果只想得到1000个元素组成的序列中第10个最小元素之前的部分排序的序列，用（）方法最快
* 冒泡排序
* 快速排序
* 希尔排序
* 堆排序

```
解答：堆排序。使用一个规模为10的最大堆，不断向里面插入数组元素；如果堆的规模超过10，就 pop 根节点（最大元素），最后堆里面就是最小的10个元素；最后依次 pop 堆的根节点，倒序即为排好序的 10 个元素。复杂度约为 1000 * log(10) ≈ 4000。

冒泡排序比较次数约为 1000 * 10。

快速排序和希尔排序都需要完全排序。
```

```
Notes: 另一种方法是使用 O(N) 的快速选择，可以挑出最小的10个元素（未排序）；然后对 10 个元素做排序。复杂度约为 1000 + 10 * log(10) ≈ 1040;

本题题目有点不符合实际。
```

---
> 问题：下列排序算法中，（）排序在一趟结束后不一定能选出一个元素放在其最终位置上
* 选择
* 冒泡
* 归并
* 堆

```
解答：归并排序的一趟是指 一次 merge(A, B) 的过程，其中 A 和 B 都是原数组中已经排序好的两个子数组，将其合并为一个较大的排序好的数组。
```

## 优先级队列

> 给定一个100万元素的基于数组的最大堆，查找堆中最小元素，需要的计算规模大约是多少？ (设log(10)=3.32)
* 100万
* 2000万
* 25万
* 20

```
解答：计算规模应该是50万。最小元素一定在叶子部分（堆是完全二叉树，也就是完全二叉树的最深的部分），恰好是数组的后一半部分。
本题没有合适的选项。
```

## 哈希表

> 问题：一个规模为11的哈希表，采用哈希函数Hash(key) = key mod 11，用哈希表外的线性表存放冲突结点，向其依次插入17，12，24，60，29，38，35，46，查找46需要____次查找
* 1
* 3
* 8
* 11

```
解答： 

Open Hashing (Separate Chaining):

In open hashing, keys are stored in linked lists attached to cells of a hash table.

Closed Hashing (Open Addressing):

In closed hashing, all keys are stored in the hash table itself without the use of linked lists.

本题为 Closed Hashing Table。建表过程如下

17 -> 6, 12 -> 1, 24 -> 2, 60 -> 5, 29 -> 7, 38 -> 5 -> 6 -> 7 -> 8,  
35 -> 3, 46 -> 2 -> 3 -> 4

因此查找 46 需要 3 次查找。
```